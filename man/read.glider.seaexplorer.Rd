% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seaexplorer.R
\name{read.glider.seaexplorer}
\alias{read.glider.seaexplorer}
\title{Read a Seaexplorer Glider file}
\usage{
read.glider.seaexplorer(file, missingValue = 9999,
  nameMap = list(conductivity = "GPCTD_CONDUCTIVITY", temperature =
  "GPCTD_TEMPERATURE", temperature = "Temperature", pressure =
  "GPCTD_PRESSURE", depth = "NAV_DEPTH", depth = "Depth", heading =
  "Heading", pitch = "Pitch", roll = "Roll"), debug = 0)
}
\arguments{
\item{file}{A connection or a character string naming the file to load.}

\item{missingValue}{Numerical value for missing data; all such values
are set to \code{NA} in the data as interpreted. The default value
works for one particular mission that was examined, but it might
not apply to other missions. When in doubt as to the correct value,
use \code{summary()} on the returned object, and check to see if the
data maximum is a peculiar value, e.g. 99, 999 or, as the default, 9999.}

\item{nameMap}{List used to rename data columns. See \dQuote{Details}.}

\item{debug}{Integer indicating the debugging level; 0 for quiet
action and higher values for more indications of the processing
steps.}
}
\description{
These files do not use standard names for variables, but
the \code{nameMap} argument facilitates renaming for storage
in the returned object. (Renaming simplifies later analysis, e.g.
permitting direct use of algorithms in the \code{oce} package,
which assume that salinity is named \code{"salinity"}, etc.)
The original names of data items are retained in the metadata
of the returned object, so that the \code{[[} operator in the \code{oce}
package can retrieve the data using either the original name
(e.g. \code{x[["sci_water_temp"]]}) or the more standard
name (e.g. \code{x[["temperature"]]}). In addition to names
given in \code{nameMap}, several other name/value inferences
are made, e.g. a character timestamp (named differently in gli
and pld1 files) is used to compute \code{time}, and similar actions
are done to infer \code{longitude} and \code{latitude},
which are in a combined degree+minute format that is
decoded by \code{\link{degreeMinute}}.
}
\examples{
library(oceanglider)
yo <- 200
url <- "ftp://ftp.dfo-mpo.gc.ca/glider/realData/SEA024/M32"
glif <- download.glider(url, paste("gli.sub.", yo, ".gz$", sep=""), debug=1)
pldf <- download.glider(url, paste("pld1.sub.", yo, ".gz$", sep=""), debug=1)
if (!is.null(pldf) && !is.null(glif)) {
    gli <- read.glider.seaexplorer(glif)
    pld <- read.glider.seaexplorer(pldf)
    ## Plot depth-time (as a way to learn about gli and pld differences)
    par(mfrow=c(2, 1))
    tlim <- range(c(gli[['time']], pld[['time']]))
    oce.plot.ts(gli[['time']], gli[['depth']], type='p', xlim=tlim, ylab="Depth [m]")
    points(pld[['time']], pld[['depth']], col=2, pch=3)
    legend("topleft", col=c(1,2), pch=c(1,3), legend=c("gli", "pld"))
    oce.plot.ts(gli[['time']], gli[['pitch']], type='p', xlim=tlim, ylab="Pitch [deg]")
    abline(h=0, col='gray')
    legend("topleft", col=1, pch=1, legend="gli")
    ## Compute glide ratio (as a way to learn about lon and lat)
    S <- function (x) diff(range(x))
    rgli <- S(geodDist(gli[['longitude']],gli[['latitude']],alongPath=TRUE))*1e3/S(gli[['depth']])
    message("glide ratio: ", rgli, " from gli file")
    rpld <- S(geodDist(pld[['longitude']],pld[['latitude']],alongPath=TRUE))*1e3/S(pld[['depth']])
    message("glide ratio: ", rpld, " from pld file")
    ## Experiments for isolating downcast (FIXME: is that preferred?)
    selectNavState <- 117 # 100 is going up
    selected <- runmed(gli[["NavState"]], 3) == selectNavState
    istart <- which(selected)[1]
    tstart <- gli[["time"]][istart]
    iend <- rev(which(selected))[1]
    tend <- gli[["time"]][iend]
    par(mfrow=c(3, 1), mar=c(3, 3, 1, 1), mgp=c(2, 0.7, 0))
    plot(gli[['time']], gli[['depth']])
    abline(v=gli[['time']][c(istart, iend)], col=2)
    plot(gli[['time']], gli[['pitch']])
    abline(v=gli[['time']][c(istart, iend)], col=2)
    plot(gli[['time']], gli[['NavStat']])
    abline(v=gli[['time']][c(istart, iend)], col=2)
    ## Examine some details.
    ## Isolate science data using start/end inferred from gli[["NavState"]]
    ctd <- as.ctd(pld)
    focus <- tstart <= pld[["time"]] & pld[["time"]] <= tend
    col <- ifelse(focus, "black", "red")
    par(mfcol=c(3, 1), mar=c(3, 3, 1, 1), mgp=c(2, 0.7, 0))
    plot(ctd[["time"]], ctd[["pressure"]], type="p")
    points(ctd[["time"]][focus], ctd[["pressure"]][focus], pch=20, col=2)
    plot(ctd[["time"]], ctd[["SA"]], type="p")
    points(ctd[["time"]][focus], ctd[["SA"]][focus], pch=20, col=2)
    plot(ctd[["time"]], ctd[["CT"]], type="p")
    points(ctd[["time"]][focus], ctd[["CT"]][focus], pch=20, col=2)
    par(mfcol=c(1, 3), mar=c(3, 3, 1, 1), mgp=c(2, 0.7, 0))
    plotProfile(ctd, xtype="salinity", type="p")
    points(ctd[["SA"]][focus], ctd[["pressure"]][focus], pch=20, col=2)
    plotProfile(ctd, xtype="temperature", type="p")
    points(ctd[["CT"]][focus], ctd[["pressure"]][focus], pch=20, col=2)
    plotTS(ctd, type="p")
    points(ctd[["SA"]][focus], ctd[["CT"]][focus], pch=20, col=2)
}

}
\seealso{
Other functions for seaexplorer gliders: \code{\link{download.glider.seaexplorer}}

Other functions to read glider data: \code{\link{read.glider.slocum}}
}
\author{
Dan Kelley
}
\concept{functions for seaexplorer gliders}
\concept{functions to read glider data}
