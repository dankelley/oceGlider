---
title: "Handling SeaExplorer Data"
author: "Dan Kelley (https://orcid.org/0000-0001-7808-5911)"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
    fig_caption: yes
    fig_width: 6
    fig_height: 4
    dpi: 72
vignette: >
  %\VignetteIndexEntry{Handling SeaExplorer Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

**Abstract.** This vignette explains the basics of working with data from
SeaExplorer gliders.  It is VERY MUCH a work in progress, not much more than a
skeleton.

# Raw Files


The below shows how to download a small number of files (just 5) from the
CPROOF server at Reference 1. The code worked as of 2024-08-29, but if reader
finds that the server has changed, the solution is to alter the value of
`urlbase` in line 2 below.

```{r}
n <- 6 # number of files to download
urlRaw <- paste0(
    "https://cproof.uvic.ca/gliderdata/deployments/",
    "dfo-eva035/dfo-eva035-20231019/",
    "delayed_raw/"
)
subs <- paste0("sea035.118.gli.sub.", 1:n)
raws <- paste0("sea035.118.pld1.raw.", 1:n)
for (i in 1:n) {
    if (!file.exists(subs[i])) {
        download.file(paste0(urlRaw, subs[i]), subs[i])
    }
    if (!file.exists(raws[i])) {
        download.file(paste0(urlRaw, raws[i]), raws[i])
    }
}
```

Note that the above is based on the assumption that the server holds the `sub`
and `pld1` files in the same directory.  If your server holds them in separate
directories, it should be a simple matter to alter the lines defining `subs`
and `raws` in the above.


The following produces a plot that summarizes key hydrographic properties, in a
format that is quite useful for an initial look at the data.

```{r fig.height=4, fig.width=7, fig.cap="**Figure 1. An overview of the raw data. Note the spurious values in the time-series plots for the first hour or two.**", dev.args=list(pointsize=12)}
library(oce)
library(oceglider)
g <- read.glider.seaexplorer.delayed(".")
layout(matrix(c(2, 1, 3, 1, 4, 1), byrow = TRUE, nrow = 3), widths = c(0.6, 0.4))
plot(g, which = "TS")
plot(g, which = "p", type = "p", cex = 0.3)
plot(g, which = "T", type = "p", cex = 0.3)
plot(g, which = "S", type = "p", cex = 0.3)
```

Inspection reveals spurious (non-oceanographic) signals for the first hour or
two, with low pressures, high temperatures and very low salinities. Reasoning
that these spurious data resulted from the instrument having been set to record
a few hours before deployment, an analyst might choose to discard those data.
This can be done with the `subset()` function, e.g. as follows.

```{r fig.height=4, fig.width=7, fig.cap="**Figure 2. Raw data, after trimming spurious data in the 1.5 hours following power-on events.**", dev.args=list(pointsize=12)}
g2 <- subset(g, time > as.POSIXct("2023-10-19 20:30:00", tz = "UTC"))
layout(matrix(c(2, 1, 3, 1, 4, 1), byrow = TRUE, nrow = 3), widths = c(0.6, 0.4))
plot(g2, which = "TS")
plot(g2, which = "p", type = "p", cex = 0.3)
plot(g2, which = "T", type = "p", cex = 0.3)
plot(g2, which = "S", type = "p", cex = 0.3)
```

The spurious data are now gone, so that this new `g2` version certainly looks
more like oceanographic data collected with a glider. Note how pressure
increases as the glider descends and then decreases as it ascends. Temperature
decreases with depth, and salinity increases.

SeaExplorer gliders store a record of `navState`, which
is stored as a numerical code, as follows.

* 105 means the glider is not navigating yet;
* 115 means the glider is surfacing in preparation for communication;
* 116 means the glider is at the surface, acquiring a GPS signal, and is communicating;
* 110 means the glider is inflecting downward;
* 100 means the glider has ballast set to be descending;
* 118 means the glider has ballast adjusted to reduce density, so will be inflecting upward;
* 117 means the glider has ballast set to be ascending.

There is a way to see the transition from one state to another,
as follows.

```{r}
par(mfrow = c(1, 1))
plot(g2, which = "navState")
```

Another useful operation is to look at individual yos, which can be done as
follows.  Note the extraction of the data from the `payload1` item.

```{r}
# Show first 4 yos in a 2x2 matrix
payload <- g2[["payload"]]
s <- split(payload, payload$yoNumber)
par(mfrow = c(2, 2))
for (ss in s[1:4]) {
    ctd <- oce::as.ctd(
        salinity = ss[["salinity"]],
        temperature = ss[["temperature"]],
        pressure = ss[["pressure"]],
        longitude = ss[["longitude"]],
        latitude = ss[["latitude"]]
    )
    oce::plotProfile(ctd, xtype = "salinity+temperature", eos = "unesco")
    mtext(sprintf("yo %d", ss$yoNumber[1]), line = -1, cex = par("cex"))
}
```

From the labels in the plots, it is evident that the data removed from the
start of the sampling were contained within the first yo, as numbered in the
data files.

Note that the plots show both the downcast and the upcast portions of the yo.


Waterfall plots are also useful, and they are easily
constructed, with lower-level oce code.

```{r}
par(mfrow = c(1, 1))
# use limits based on all yos, to avoid clipping
Tlim <- range(sapply(s, \(ss) range(ss[["temperature"]], na.rm = TRUE)))
plim <- rev(range(sapply(s, \(ss) range(ss[["pressure"]], na.rm = TRUE))))
for (i in seq_along(s)) {
    ss <- s[[i]]
    ctd <- oce::as.ctd(
        salinity = ss$salinity,
        temperature = ss$temperature,
        pressure = ss$pressure,
        longitude = ss$longitude,
        latitude = ss$latitude
    )
    ctd <- oce::ctdTrim(ctd, "upcast")
    if (i == 1) {
        oce::plotProfile(ctd,
            xtype = "temperature", eos = "unesco",
            Tlim = Tlim, plim = plim
        )
    } else {
        lines(ctd[["temperature"]], ctd[["pressure"]], col = i)
    }
}
legend("bottomright",
    title = "Start Time",
    lwd = 1, col = seq_along(s), cex = 0.75, bg = "white",
    legend = sapply(s, function(ss) format(ss$time[[1]], "%H:%S"))
)
```

# Delayed-mode NetCDF Files

NetCDF files are likely the format that most users will be dealing with, partly
because it can be loaded quickly, and it is simple to read. The sample file,
from Reference 2, corresponds to the full dataset used in the previous
discussion of raw data.

Since the file is large, it can take a minute or two to download, and so the
following code caches the file.  Note that the reading step takes only a second
or two, so the caching increases processing speed enormously.

```{r}
urlNC <- paste0(
    "https://cproof.uvic.ca/gliderdata/deployments/",
    "dfo-eva035/dfo-eva035-20231019/",
    "/L0-timeseries/dfo-eva035-20231019_delayed.nc"
)
fileNC <- gsub(".*/", "", urlNC)
# 86.8MB file, so cache it to save O(30) second download.
if (!file.exists(fileNC)) {
    download.file(urlNC, fileNC)
}
G <- read.glider.netcdf(fileNC)
```

As for the raw data, drop the data before a certain time.

```{r}
G2 <- subset(G, time > as.POSIXct("2023-10-19 20:30:00", tz = "UTC"))
```

Now that we have all the data for the mission, the sensible starting place for
graphical analysis is a map.  Note that here `type` is set to `"l"`, so that
data points are joined with lines. This helps to reveal the starting and ending
locations.

```{r}
plot(G, which = "map", type = "l")
```

The longitude and latitude axes indicating that the sampling was made off the
west coast of Canada. The first samples were likely on the east, and the glider
traveled to the southwest, before turning around and retracing its route to
about 131W.  Presumably it was picked up by a ship then.

Typically, the next step will be to see the trajectory in time-depth space, as
follows.

```{r}
plot(G2, which = "p")
```

Notice that there are so many yos in the shallow water that the plot is covered
in black for the first several days. When it reaches
deep water, however, the yos take longer and so individual
ascents and descents are (barely) discernible. The system
was clearly set up to descent only to 1km depth at most.

It may be interesting to see temperature and salinity variations over the
continental shelf, so we select the first week of data.

```{r}
G3 <- subset(G2, time < G[["time"]][1] + 7 * 86400)
temperature <- G3[["temperature"]]
cmT <- oce::colormap(temperature, col = oceColorsTurbo)
salinity <- G3[["salinity"]]
cmS <- oce::colormap(salinity, col = oceColorsTurbo)
par(mfrow = c(2, 1))
par(mar = c(3, 3, 1, 1))
drawPalette(colormap = cmT)
plot(G3, which = "p", type = "p", col = cmT$zcol, mar = c(3, 3, 1, 4))
par(mar = c(3, 3, 1, 1))
drawPalette(colormap = cmS)
plot(G3, which = "p", type = "p", col = cmS$zcol, mar = c(3, 3, 1, 4))
```

This representation does not rely on gridding to fill in spots between the
data, but it can be subject to problems with overpainting of colours from later
yos obscuring colours from earlier rows.  One way around that is to use the
`sample()` function to randomly order the data points, but, for that, the
generic `plot()` used above will need to be replaced by lower-level plot calls.
(Readers with experience in this will know how to do it; others ought to think
the problem through, because this is quite a useful method.)

**Exercises.**

1. Set up the `sample()` scheme to see if overpainting is a problem. Also,
   try adjusting symbol size.
2. Extract oxygen, and colour-code the plot for that.
3. (Advanced) Explore gridding options, to cast the data onto a uniform
   time-depth grid.  If deemed of interest, try gridding also for
   a lateral coordinate instead of time.

# References

1. "Index of
   /Gliderdata/Deployments/Dfo-Eva035/Dfo-Eva035-20231019/Realtime_raw."
   Accessed September 2, 2024.
   <https://cproof.uvic.ca/gliderdata/deployments/dfo-eva035/dfo-eva035-20231019/realtime_raw/>.

2. "Time series Delayed [dfo-eva035/dfo-eva035-20231019_delayed.nc]."
   Accessed September 2, 2024.
   <https://cproof.uvic.ca/gliderdata/deployments/dfo-eva035/dfo-eva035-20231019/L0-timeseries/dfo-eva035-20231019_delayed.nc>


